//
//  MapController.swift
//  optimismMap
//
//  Created by Johnson Zhou on 1/30/15.
//  Copyright (c) 2015 Optimist. All rights reserved.
//

import UIKit
import MapKit

class PickMapController: UIViewController,MKMapViewDelegate,CLLocationManagerDelegate {
    
    required init(coder aDecoder: NSCoder) {
        self.locationManger = CLLocationManager()           //location service
        self.popOver = WYPopoverController()                //this controls callout views
        super.init(coder: aDecoder)
        self.locationManger.delegate = self                 //setting locatiion manager delegate to view controller
        self.locationManger.desiredAccuracy = kCLLocationAccuracyBest   //since we are walking, best accuracy is needed
    }
    
    var packageList:NSMutableArray = NSMutableArray()       //Stores the "beams" on the map
    var locationManger:CLLocationManager
    var mapPackages = []                                    //package of annotations
    var popOver:WYPopoverController
    var isTracking = true                                   //if we are tracking or not
    
    
    @IBAction func pressCenter(sender: UIBarButtonItem) {           //this is the button "track"
        isTracking = true                                   //this means we are tracking!!!
        var coord = self.MainMap.userLocation.location.coordinate
        var region = MKCoordinateRegionMakeWithDistance(coord, 200, 200)
        self.MainMap.setRegion(region, animated: true)      //adjust to good level of view
    }
    
    @IBOutlet weak var MainMap: MKMapView!                  //outlet to the mapview
    
    func mapView(mapView: MKMapView!, didUpdateUserLocation userLocation: MKUserLocation!) {
        if isTracking {
            self.MainMap.setCenterCoordinate(userLocation.location.coordinate, animated: true)
        }                                                   //manually track user
        reloadAnnotation()                                  //reload to see if we unlock more
    }
    
    func mapView(mapView: MKMapView!, rendererForOverlay overlay: MKOverlay!) -> MKOverlayRenderer! {       //just a renderer for the custom tiles
        if (overlay.isKindOfClass(MKTileOverlay)) {
            return MKTileOverlayRenderer(overlay: overlay)
        } else
        {
            return nil;
        }
    }
    /*
    No need for this, auto generated by push segue
    
    @IBAction func goBack(sender: AnyObject) {
        
        self.navigationController?.popViewControllerAnimated(true)
        
    }*/
    
    func mapView(mapView: MKMapView!, regionWillChangeAnimated animated: Bool) {
        isTracking = false
    } //user dragged the map, no longer tracking
    
    override func viewDidLoad() {
        
        super.viewDidLoad()
        
        
        /*
         * trying to get data from the other viewcontrollers, place holder
         * need to change this to better solution
         */
        
        var defaults = NSUserDefaults.standardUserDefaults()
        var status : [Bool] = [Bool]()
        if let testArray : AnyObject? = defaults.objectForKey("theBool") {
            status = testArray! as! [Bool]
        }
        
        self.locationManger.requestWhenInUseAuthorization() //request user location, maybe change this to appdelegate?
        self.MainMap.delegate = self
        self.MainMap.setUserTrackingMode(MKUserTrackingMode.Follow, animated: true) //initial tracking, to update the view
        self.MainMap.pitchEnabled = false   //disable 3D
        
        // networking begin
        var request = NSMutableURLRequest(URL: NSURL(string: "http://www.coryamayer.com/optimism/query.php")!)
        let dicLat = "&lat="
        let dicLon = "&lon="
        var dicMotion = ["angry","anxious","annoyed","depressed","down","heartbroken","hopeless","hurting",
            "irritable","mournful","nervous","pissed","regretful","resentful","sad","scared","sick","stressed","sulky"
            ,"worthless"]
        
        var requestString = "key=hack"
        requestString = requestString + dicLat + self.MainMap.userLocation.coordinate.latitude.description + dicLon + self.MainMap.userLocation.coordinate.latitude.description
        for index in 0...19 {
            requestString = requestString + "&" + dicMotion[index] + "="
            if status[index] {
                requestString = requestString + "1"
            } else {
                requestString = requestString + "0"
            }
        }
        // was preparing request
        
        var requestData = requestString.dataUsingEncoding(NSUTF8StringEncoding) //actual request
        
        request.HTTPMethod = "POST"
        request.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "content-type")
        request.HTTPBody = requestData
        var returnData = NSURLConnection.sendSynchronousRequest(request, returningResponse: nil, error: nil)
        NSLog(NSString(data: returnData!, encoding: NSUTF8StringEncoding) as String!)
        var returnDic = NSPropertyListSerialization.propertyListWithData(returnData!, options: 0, format: nil, error: nil) as! NSDictionary
        var NumString = returnDic["numberOfPins"] as! NSString
        var NumCount = NumString.integerValue
        
        // casting data received as a dictonary (which was a plist)
        
        var thisPackage:NSDictionary
        var lat:NSString
        var lon:NSString
        if (NumCount > 0) {
        for index in 0...(NumCount-1) {
            thisPackage = returnDic[String(index)] as! NSDictionary
            lat = thisPackage["lat"] as! NSString
            lon = thisPackage["lon"] as! NSString
            packageList.addObject(beamPackage(beamMsg: thisPackage["message"] as! String, LocLat: lat.doubleValue, LocLon: lon.doubleValue))
            
        }
        }
        //networking end
        
        let template = "http://otile1.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.jpg"   //custom tiles from mapcdn
        var overlay = MKTileOverlay(URLTemplate: template)
        overlay.canReplaceMapContent = true             //so we can replace the tiles
        
        self.MainMap.addOverlay(overlay, level: MKOverlayLevel.AboveLabels)     //adding the tile overlay
        
        for currentItem in packageList {
            var thisItem = currentItem as! beamPackage
            self.MainMap.addAnnotation(beamAnnotation(msg: thisItem.msg, location: CLLocationCoordinate2DMake(thisItem.lat, thisItem.lon)))
        }       //getting data from the server to local arrays
        
    }
    
    func mapView(mapView: MKMapView!, viewForAnnotation annotation: MKAnnotation!) -> MKAnnotationView! {
        
        var currentLocation = self.MainMap.userLocation.coordinate
        var annotationView:MKAnnotationView?

        if annotation.isKindOfClass(beamAnnotation) {
            
            var thisLocation = annotation as! beamAnnotation
            let thisLat:Double = thisLocation.coordinate.latitude
            let currentLat:Double = currentLocation.latitude
            
            //check to see if current location is close to the package, if it is close, use the "unlock" view, else, use lock view.
            let closeLat = fabs(currentLat - thisLat) < 0.0002
            let closeLong = fabs(thisLocation.coordinate.longitude - currentLocation.longitude) < 0.0002
            if (closeLat && closeLong) {
                 annotationView = mapView.dequeueReusableAnnotationViewWithIdentifier("AnnoUnlock")
                if annotationView == nil {
                    annotationView = thisLocation.annotationViewUnlocked()
                } else {
                    annotationView?.annotation = annotation
                }
            } else {
                annotationView = mapView.dequeueReusableAnnotationViewWithIdentifier("AnnoLock")
                if annotationView == nil {
                    annotationView = thisLocation.annotationViewLocked()
                } else {
                    annotationView?.annotation = annotation
                }
            }
            return annotationView
        }
        else {
          return nil
        }
    }
    
    //this handles the custom call out
    // thanks to WYPopovercontroller, we can do popover on iPhone :)
    
    func mapView(mapView: MKMapView!, didSelectAnnotationView view: MKAnnotationView!) {
    
       mapView.deselectAnnotation(view.annotation, animated: true)
        if (view.annotation.isKindOfClass(beamAnnotation)) {
            var thisAnnotation = view.annotation as! beamAnnotation
            
            var controller = CallOutViewController(nibName: "CallOutViewController", bundle: nil) //initialize the viewcontroller for callout
            controller.msg = thisAnnotation.msg                     //setting the callout message
            controller.preferredContentSize = CGSizeMake(240,150)      //Well, it looks like these number works the best
            
            popOver = WYPopoverController(contentViewController: controller)
            var thisLocation = thisAnnotation.coordinate
            var currentLocation = self.MainMap.userLocation.coordinate
            let thisLat:Double = thisLocation.latitude
            let currentLat:Double = currentLocation.latitude
            
            //had to check it again, something is spooky here, need investigate!
            let closeLat = fabs(currentLat - thisLat) < 0.0002
            let closeLong = fabs(thisLocation.longitude - currentLocation.longitude) < 0.0002
            
            if (closeLat && closeLong) {
                popOver.presentPopoverFromRect(view.bounds,inView:view,permittedArrowDirections:WYPopoverArrowDirection.Any, animated:true, options: WYPopoverAnimationOptions.FadeWithScale)
            }
        }
        
        
    }
    
    func reloadAnnotation() {           // this just reloads the annotations
        
        var currentLocation:MKAnnotation? = self.MainMap.userLocation
        var annotations = self.MainMap.annotations
        self.MainMap.removeAnnotations(annotations)
        if currentLocation != nil {
            self.MainMap.addAnnotation(currentLocation)
        }
        
        for currentItem2 in packageList {
            var thisItem = currentItem2 as! beamPackage
            self.MainMap.addAnnotation(beamAnnotation(msg: thisItem.msg, location: CLLocationCoordinate2DMake(thisItem.lat, thisItem.lon)))
        }
    }
    
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
}
